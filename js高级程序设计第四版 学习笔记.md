# 第四章 变量 作用域 与内存

## 1.确定类型

1.1按照定义,所有引用值都是Object的实例,因此通过instanceof操作符检测任何引用值喝Object构造函数都会返回true,类似的,如果用intanceof检测原始值,则始终返回false,因为原始值不是对象.

## 2.执行上下文作用域

2.1变量或函数的上下文决定了他们可以访问那些数据,以及他们的行为,每个上下文都有一个关联的变量对象,而在这个上下文中定义的所有变量和函数都存在这个对象上.虽然无法通过代码访问变量,但后台处理数据会用到他.全局上下文是最外层的上下文,根据ECMAScript实现的宿主环境,表示全局上下文的对象,可能不一样.在浏览器中,全局上下文就是我们所说的window对象,所有通过var定义的全局变量和函数都会成为window对象的属性和方法.是用let和const的顶级声明不会全局上下文中,但在作用域链的解析效果上是一样的.上下文在其所有代码都执行完毕后会被销毁,包括定义在他上面的所有变量和函数,(全局上下文在应用程序退出前才会被销毁,比如关闭网页和退出浏览器),每个函数调用都有自己的上下文,当代码执行流进入函数的时,函数的上下文被推到一个上下文栈上在函数执行完毕之后,上下文会弹出该函数上下文,将控制权返还给之前的执行上下文,ECMAScript程序的执行流就是通过这个上下文栈进行控制的.上下文的代码在执行的时候,会创建变量对象的一个作用域链,这个作用域链决定了各级上下文中的代码的访问变量和函数的顺序,代码正在执行的上下文的变量对象始终位于作用域链的最前端,如果上下文是函数,则其活动对象用作变量对象,活动对象最初只用一个定义变量,arguments.(全局上下文中没有这个变量)作用域链中的下一个变量对象来自包含上下文,再下一个对象来自再下一个包含上下文,一次内推至全局上下文,全局上下文的变量对象始终是作用域链的最后一个变量对象.代码执行时的标识符解析是通过沿作用域链的最前端开始,然后逐级往后,直到找到标识符,如果没有找到标识符就会报错.

2.2虽然执行上下文有全局上下文和函数上下文两种(eval()调用内部存在第三种上下文),但有其他方式来增强作用域链,某些语句会在作用域链前端临时添加一个上下文,这个上下文在执行后会被删除,通常在两种情况下会出现这种情况, 1try/catch语句中的catch块 2with语句   这两种情况下,都会在作用域链前端添加一个变量对象, 对with语句来说,会向作用域链前端添加指定对象,对catch语句而言,则会创建一个新的变量对象,这个变量对象包含要抛出的错误对象声明.

2.3使用var声明的变量会自动被添加到最接近的上下文中,在函数中,最接近的上下文就是函数的局部上下文,在with语句中,最接近的上下文是函数上下文,如果变量未经声明就初始化了,那么它会自动被添加到全局上下文中;

2.4在同一个作用域中可以使用var关键字对一个变量进行重复声明,但是对let不可以

2.5如果想让整个对象都不能修改,可以使用Object.freeze()这样再给属性赋值时虽然不会报错,但会静默失败

## 3.垃圾回收机制

1.1JavaScript是使用垃圾回收的语言,也就是说执行环境负责在代码执行时管理内存.



