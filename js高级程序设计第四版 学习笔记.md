# 第四章 变量 作用域 与内存

## 1.确定类型

1.1按照定义,所有引用值都是Object的实例,因此通过instanceof操作符检测任何引用值喝Object构造函数都会返回true,类似的,如果用intanceof检测原始值,则始终返回false,因为原始值不是对象.

## 2.执行上下文作用域

2.1变量或函数的上下文决定了他们可以访问那些数据,以及他们的行为,每个上下文都有一个关联的变量对象,而在这个上下文中定义的所有变量和函数都存在这个对象上.虽然无法通过代码访问变量,但后台处理数据会用到他.全局上下文是最外层的上下文,根据ECMAScript实现的宿主环境,表示全局上下文的对象,可能不一样.在浏览器中,全局上下文就是我们所说的window对象,所有通过var定义的全局变量和函数都会成为window对象的属性和方法.是用let和const的顶级声明不会全局上下文中,但在作用域链的解析效果上是一样的.上下文在其所有代码都执行完毕后会被销毁,包括定义在他上面的所有变量和函数,(全局上下文在应用程序退出前才会被销毁,比如关闭网页和退出浏览器),每个函数调用都有自己的上下文,当代码执行流进入函数的时,函数的上下文被推到一个上下文栈上在函数执行完毕之后,上下文会弹出该函数上下文,将控制权返还给之前的执行上下文,ECMAScript程序的执行流就是通过这个上下文栈进行控制的.上下文的代码在执行的时候,会创建变量对象的一个作用域链,这个作用域链决定了各级上下文中的代码的访问变量和函数的顺序,代码正在执行的上下文的变量对象始终位于作用域链的最前端,如果上下文是函数,则其活动对象用作变量对象,活动对象最初只用一个定义变量,arguments.(全局上下文中没有这个变量)作用域链中的下一个变量对象来自包含上下文,再下一个对象来自再下一个包含上下文,一次内推至全局上下文,全局上下文的变量对象始终是作用域链的最后一个变量对象.代码执行时的标识符解析是通过沿作用域链的最前端开始,然后逐级往后,直到找到标识符,如果没有找到标识符就会报错.

2.2虽然执行上下文有全局上下文和函数上下文两种(eval()调用内部存在第三种上下文),但有其他方式来增强作用域链,某些语句会在作用域链前端临时添加一个上下文,这个上下文在执行后会被删除,通常在两种情况下会出现这种情况, 1try/catch语句中的catch块 2with语句   这两种情况下,都会在作用域链前端添加一个变量对象, 对with语句来说,会向作用域链前端添加指定对象,对catch语句而言,则会创建一个新的变量对象,这个变量对象包含要抛出的错误对象声明.

2.3使用var声明的变量会自动被添加到最接近的上下文中,在函数中,最接近的上下文就是函数的局部上下文,在with语句中,最接近的上下文是函数上下文,如果变量未经声明就初始化了,那么它会自动被添加到全局上下文中;

2.4在同一个作用域中可以使用var关键字对一个变量进行重复声明,但是对let不可以

2.5如果想让整个对象都不能修改,可以使用Object.freeze()这样再给属性赋值时虽然不会报错,但会静默失败

## 3.垃圾回收机制

1.1JavaScript是使用垃圾回收的语言,也就是说执行环境负责在代码执行时管理内存.

# 第五章基本引用类型

## 前言

1.1引用值是某个特定引用类型的实例

## 1.Date

1.1Date类型可以精确的表示1970年1月1日之前及之后285616年的日期；

1.2要创建日期对象，就使用new操作符来调用Date构造函数在不给Date构造函数传递参数的情况下，创建的对象将保存当前日期和时间，要基于其他时间和日期创建对象，必须传入其毫秒表示（UNIX纪元1970年1月1日午夜之后的毫秒数）。ECMAScript为此提供了两个辅助方法： Date.parse()和Date.UTC(),Date.parse()接收一个表示日期的字符串的参数，尝试将这个字符串转换为表示该日期的毫秒数，Date.UTC()的参数是年、零起点月数（1月是0，以此往后推），日（1-31），时（0-23），分，秒，毫秒，只有年月时必须的，如果不提供日，那么默认为1日，其他的参数的默认值都是0，如果创建日期对象的时候后端没有给这传入的参数调用这两个方法，后台时默认自动会调的。



# 2.原始包装类型

2.1为了方便操作原始值，ECMAScript提供了三种特殊的引用类型，：Boolean, Number, String这些类型具有本章介绍的其他引用类型一样的特点，但也具有与各自原始类型对应的特殊行为，每当用到某个原始值的方法或者属性的时候，后台都会创建一个相应原始包装类型的对象，从而暴漏出操作原始值的各种方法，

```
let s1 = "some text"; 
let s2 = s1.substring(2); 
```

在这里，s1是一个包含字符串的变量，它时一个原始值，第二行紧接着在s1上调用了substring()方法，并把结果保存在s2中，原始值本身不是对象，因此逻辑上不应该有此方法，，而实际上这个例子又确实按照预期运行了。这是因为后台进行了很多处理，从而实现了上述操作，当第二行访问s1的时候，是以读的模式访问的，也就是要从内存中读取变量保存的值，在以读模式访问字符串的，也就是先要从内存中读取变量保存的值，在以读模式访问字符串的值的任何时候，后台都会执行一下三个步骤：

​		（1）创建一个String类型的实例

​		（2)  调用实例上面的方法

​		（3）销毁实例

可以把这3步想象成执行了如下3行ECMAScript代码：

 

```
let s1 = new String("some text");
let s2 = s1.substring(2);
s1 = null;
```

这种行为可以让原始值拥有对象的行为，对于布尔值和数值而言，以上三步也会在后台发生，只不过使用的是Boolean和Number包装类型而已。

2.2引用类型和原始值包装类型的主要区别在于对象的生命周期，在通过new实例化引用类型后，得到的实例会在离开作用域的时候被销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期间。

2.3 Object构造函数作为一个工厂方法，能够根据传入值的类型返回相应的原始值的包装类型的实例

```
let obj = new Object("some text");
console.log(obj instanceof String);  // true 
```

## 3.单例内置对象

1.ECMA-262对内置对象的定义是任何由ECMAScript实现提供、与宿主环境无关，并在ECMAScript程序开始执行的时候就存在的对象，这就意味着开发者不用显式地实例化内置对象，因为他们已经实例化好了。

2.Global对象是ECMAScript中最特别的对象，因为代码不会显示的访问它，ECMA-262规定Global对象为一种兜底对象，它所针对的是不属于任何对象的属性和方法，事实上，不存在全局变量和全局函数这种东西，在全局作用域中定义的变量和函数都会变成Golbal对象的属性，

3.URL编码方法    encodeURI() 和 encodeURIComponent()用于编码统一资源标识符，以便传给浏览器。有效的URL不能包括某些字符，比如说空格，econdeURI()方法用于对整个URI进行编码，而encodeURIComponent()方法用于编码URI中单独的组件；

4.eval()方法就是一个ECMAScript解释器，他接收一个参数，即一个要执行的ECMAScript字符串，当解释器发现eval()调用的时候，会将参数解释为实际的ECMAScript语句，然后将其插入到该位置，通过eval()执行的代码属于该调用所在上下文，被执行的代码与该上下文拥有相同的作用域链，这意味着定义在包含上下文中的变量可以在eval()调用内部被引用；

5.当一个函数没有明确this值的情况下执行，this等于Global对象，获取Gloabl的方式

```
let global = function () {
	return this;
}()
```

虽然ECMA-262没有规定直接访问Global对象的方式，但浏览器将window对象实现为Global对象的代理。

6.当代码开始执行的时候，全局上下文中会存在两个内置对象：Global和Math,其中Global对象在大多数浏览器中无法直接访问，不过，浏览器将其实现为window对象，所有全局变量和函数都是Global对象的属性，Math对象包含辅助完成复杂计算的属性和方法。

# 第六章 集合引用类型

## 1.Object

1.1  在ECMAScript中表达式上下文值得是期待返回值的上下文；

